// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using SSHMan;
//
//    var terminalConfig = TerminalConfig.FromJson(jsonString);
using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

namespace SSHMan {

    /// <summary>
    /// Properties that affect the entire window, regardless of the profile settings.
    /// </summary>
    public partial class TerminalConfig {
        /// <summary>
        /// When set to true, tabs are always displayed. When set to false and "showTabsInTitlebar"
        /// is set to false, tabs only appear after opening a new tab.
        /// </summary>
        [JsonProperty ("alwaysShowTabs", NullValueHandling = NullValueHandling.Ignore)]
        public bool? AlwaysShowTabs { get; set; }

        /// <summary>
        /// When set to "true" closing a window with multiple tabs open will require confirmation.
        /// When set to "false", the confirmation dialog will not appear.
        /// </summary>
        [JsonProperty ("confirmCloseAllTabs", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ConfirmCloseAllTabs { get; set; }

        /// <summary>
        /// When set to `true`, the color and font formatting of selected text is also copied to your
        /// clipboard. When set to `false`, only plain text is copied to your clipboard.
        /// </summary>
        [JsonProperty ("copyFormatting", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CopyFormatting { get; set; }

        /// <summary>
        /// When set to true, a selection is immediately copied to your clipboard upon creation. When
        /// set to false, the selection persists and awaits further action.
        /// </summary>
        [JsonProperty ("copyOnSelect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? CopyOnSelect { get; set; }

        /// <summary>
        /// Sets the default profile. Opens by clicking the "+" icon or typing the key binding
        /// assigned to "newTab". The "guid" of the desired default profile is used as the value.
        /// </summary>
        [JsonProperty ("defaultProfile", NullValueHandling = NullValueHandling.Ignore)]
        public string DefaultProfile { get; set; }

        /// <summary>
        /// Disables all the dynamic profile generators in this list, preventing them from adding
        /// their profiles to the list of profiles on startup.
        /// </summary>
        [JsonProperty ("disabledProfileSources", NullValueHandling = NullValueHandling.Ignore)]
        public List<DynamicProfileSource> DisabledProfileSources { get; set; }

        /// <summary>
        /// When set to true, we will redraw the entire screen each frame. When set to false, we will
        /// render only the updates to the screen between frames.
        /// </summary>
        [JsonProperty ("experimental.rendering.forceFullRepaint", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRenderingForceFullRepaint { get; set; }

        /// <summary>
        /// When set to true, we will use the software renderer (a.k.a. WARP) instead of the hardware
        /// one.
        /// </summary>
        [JsonProperty ("experimental.rendering.software", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRenderingSoftware { get; set; }

        /// <summary>
        /// The number of columns displayed in the window upon first load.
        /// </summary>
        [JsonProperty ("initialCols", NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialCols { get; set; }

        /// <summary>
        /// The position of the top left corner of the window upon first load. On a system with
        /// multiple displays, these coordinates are relative to the top left of the primary display.
        /// If "launchMode" is set to maximized, the window will be maximized on the monitor
        /// specified by those coordinates.
        /// </summary>
        [JsonProperty ("initialPosition", NullValueHandling = NullValueHandling.Ignore)]
        public string InitialPosition { get; set; }

        /// <summary>
        /// The number of rows displayed in the window upon first load.
        /// </summary>
        [JsonProperty ("initialRows", NullValueHandling = NullValueHandling.Ignore)]
        public long? InitialRows { get; set; }

        /// <summary>
        /// Properties are specific to each custom key binding.
        /// </summary>
        [JsonProperty ("keybindings", NullValueHandling = NullValueHandling.Ignore)]
        public List<Keybinding> Keybindings { get; set; }

        /// <summary>
        /// Defines whether the Terminal will launch as maximized or not.
        /// </summary>
        [JsonProperty ("launchMode", NullValueHandling = NullValueHandling.Ignore)]
        public LaunchMode? LaunchMode { get; set; }

        /// <summary>
        /// The number of rows to scroll at a time with the mouse wheel. This will override the
        /// system setting if the value is not zero or "system".
        /// </summary>
        [JsonProperty ("rowsToScroll", NullValueHandling = NullValueHandling.Ignore)]
        public RowsToScroll? RowsToScroll { get; set; }

        /// <summary>
        /// When set to true, the tabs are moved into the titlebar and the titlebar disappears. When
        /// set to false, the titlebar sits above the tabs.
        /// </summary>
        [JsonProperty ("showTabsInTitlebar", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowTabsInTitlebar { get; set; }

        /// <summary>
        /// When set to true, titlebar displays the title of the selected tab. When set to false,
        /// titlebar displays "Windows Terminal".
        /// </summary>
        [JsonProperty ("showTerminalTitleInTitlebar", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ShowTerminalTitleInTitlebar { get; set; }

        /// <summary>
        /// When set to true, the window will snap to the nearest character boundary on resize. When
        /// false, the window will resize smoothly
        /// </summary>
        [JsonProperty ("snapToGridOnResize", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapToGridOnResize { get; set; }

        /// <summary>
        /// Sets the width of the tabs. Possible values include:
        /// -"equal" sizes each tab to the same width
        /// -"titleLength" sizes each tab to the length of its title
        /// </summary>
        [JsonProperty ("tabWidthMode", NullValueHandling = NullValueHandling.Ignore)]
        public TabWidthMode? TabWidthMode { get; set; }

        /// <summary>
        /// Sets the theme of the application. The special value "system" refers to the active
        /// Windows system theme.
        /// </summary>
        [JsonProperty ("theme", NullValueHandling = NullValueHandling.Ignore)]
        public Theme? Theme { get; set; }

        /// <summary>
        /// Determines the delimiters used in a double click selection.
        /// </summary>
        [JsonProperty ("wordDelimiters", NullValueHandling = NullValueHandling.Ignore)]
        public string WordDelimiters { get; set; }

        [JsonProperty ("profiles", NullValueHandling = NullValueHandling.Ignore)]
        public Profiles? Profiles { get; set; }

        [JsonProperty ("schemes", NullValueHandling = NullValueHandling.Ignore)]
        public List<SchemeList> Schemes { get; set; }
    }

    public partial class Keybinding {
        /// <summary>
        /// The action executed when the associated key bindings are pressed.
        /// </summary>
        [JsonProperty ("command")]
        public Command? Command { get; set; }

        /// <summary>
        /// Defines the key combinations used to call the command. It must be composed of...
        /// -any number of modifiers (ctrl/alt/shift)
        /// -a non-modifier key
        /// </summary>
        [JsonProperty ("keys", NullValueHandling = NullValueHandling.Ignore)]
        public Keys? Keys { get; set; }
    }

    /// <summary>
    /// Arguments corresponding to an Adjust Font Size Action
    ///
    /// Arguments corresponding to a Copy Text Action
    ///
    /// Arguments corresponding to a New Tab Action
    ///
    /// Arguments corresponding to a Switch To Tab Action
    ///
    /// Arguments corresponding to a Move Focus Action
    ///
    /// Arguments corresponding to a Resize Pane Action
    ///
    /// Arguments corresponding to a Split Pane Action
    /// </summary>
    public partial class Action {
        /// <summary>
        /// How much to change the current font point size
        /// </summary>
        [JsonProperty ("delta", NullValueHandling = NullValueHandling.Ignore)]
        public long? Delta { get; set; }

        /// <summary>
        /// The action to execute
        /// </summary>
        [JsonProperty ("action", NullValueHandling = NullValueHandling.Ignore)]
        public ActionEnum? ActionAction { get; set; }

        /// <summary>
        /// If true, the copied content will be copied as a single line (even if there are hard line
        /// breaks present in the text). If false, newlines persist from the selected text.
        /// </summary>
        [JsonProperty ("singleLine", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SingleLine { get; set; }

        /// <summary>
        /// A commandline to use instead of the profile's
        /// </summary>
        [JsonProperty ("commandline", NullValueHandling = NullValueHandling.Ignore)]
        public string Commandline { get; set; }

        /// <summary>
        /// The index of the profile in the new tab dropdown (starting at 0)
        ///
        /// Which tab to switch to, with the first being 0
        /// </summary>
        [JsonProperty ("index", NullValueHandling = NullValueHandling.Ignore)]
        public long? Index { get; set; }

        /// <summary>
        /// Either the GUID or name of a profile to use, instead of launching the default
        /// </summary>
        [JsonProperty ("profile", NullValueHandling = NullValueHandling.Ignore)]
        public string Profile { get; set; }

        /// <summary>
        /// A startingDirectory to use instead of the profile's
        /// </summary>
        [JsonProperty ("startingDirectory", NullValueHandling = NullValueHandling.Ignore)]
        public string StartingDirectory { get; set; }

        /// <summary>
        /// An initial tabTitle to use instead of the profile's
        /// </summary>
        [JsonProperty ("tabTitle", NullValueHandling = NullValueHandling.Ignore)]
        public string TabTitle { get; set; }

        /// <summary>
        /// The direction to move focus in, between panes
        ///
        /// The direction to move the pane separator in
        /// </summary>
        [JsonProperty ("direction", NullValueHandling = NullValueHandling.Ignore)]
        public Direction? Direction { get; set; }

        /// <summary>
        /// The orientation to split the pane in. Possible values:
        /// -"auto" (splits pane based on remaining space)
        /// -"horizontal" (think [-])
        /// -"vertical" (think [|])
        /// </summary>
        [JsonProperty ("split", NullValueHandling = NullValueHandling.Ignore)]
        public SplitState? Split { get; set; }

        /// <summary>
        /// Control how the pane splits. Only accepts "duplicate" which will duplicate the focused
        /// pane's profile into a new pane.
        /// </summary>
        [JsonProperty ("splitMode")]
        public object SplitMode { get; set; }
    }

    /// <summary>
    /// A list of profiles and the properties specific to each.
    ///
    /// Properties specific to a unique profile.
    ///
    /// The default settings that apply to every profile.
    /// </summary>
    public partial class ProfileList {
        /// <summary>
        /// Unique identifier of the profile. Written in registry format:
        /// "{00000000-0000-0000-0000-000000000000}".
        /// </summary>
        [JsonProperty ("guid", NullValueHandling = NullValueHandling.Ignore)]
        public string Guid { get; set; }

        /// <summary>
        /// Name of the profile. Displays in the dropdown menu.
        /// </summary>
        [JsonProperty ("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// When useAcrylic is set to true, it sets the transparency of the window for the profile.
        /// Accepts floating point values from 0-1 (default 0.5).
        /// </summary>
        [JsonProperty ("acrylicOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxValueCheckConverter))]
        public double? AcrylicOpacity { get; set; }

        /// <summary>
        /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
        /// "cleartype" and "aliased". Note that changing this setting will require starting a new
        /// terminal instance.
        /// </summary>
        [JsonProperty ("antialiasingMode", NullValueHandling = NullValueHandling.Ignore)]
        public AntialiasingMode? AntialiasingMode { get; set; }

        /// <summary>
        /// Sets the background color of the text. Overrides "background" from the color scheme. Uses
        /// hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty ("background", NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the file location of the image to draw over the window background.
        /// </summary>
        [JsonProperty ("backgroundImage")]
        public string BackgroundImage { get; set; }

        /// <summary>
        /// Sets how the background image aligns to the boundaries of the window. Possible values:
        /// "center", "left", "top", "right", "bottom", "topLeft", "topRight", "bottomLeft",
        /// "bottomRight"
        /// </summary>
        [JsonProperty ("backgroundImageAlignment", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageAlignment? BackgroundImageAlignment { get; set; }

        /// <summary>
        /// Sets the transparency of the background image. Accepts floating point values from 0-1.
        /// </summary>
        [JsonProperty ("backgroundImageOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxValueCheckConverter))]
        public double? BackgroundImageOpacity { get; set; }

        /// <summary>
        /// Sets how the background image is resized to fill the window.
        /// </summary>
        [JsonProperty ("backgroundImageStretchMode", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageStretchMode? BackgroundImageStretchMode { get; set; }

        /// <summary>
        /// Sets how the profile reacts to termination or failure to launch. Possible values:
        /// -"graceful" (close when exit is typed or the process exits normally)
        /// -"always" (always close)
        /// -"never" (never close).
        /// true and false are accepted as synonyms for "graceful" and "never" respectively.
        /// </summary>
        [JsonProperty ("closeOnExit", NullValueHandling = NullValueHandling.Ignore)]
        public CloseOnExitUnion? CloseOnExit { get; set; }

        /// <summary>
        /// Name of the terminal color scheme to use. Color schemes are defined under "schemes".
        /// </summary>
        [JsonProperty ("colorScheme", NullValueHandling = NullValueHandling.Ignore)]
        public string ColorScheme { get; set; }

        /// <summary>
        /// Executable used in the profile.
        /// </summary>
        [JsonProperty ("commandline", NullValueHandling = NullValueHandling.Ignore)]
        public string Commandline { get; set; }

        /// <summary>
        /// Sets the color of the cursor. Overrides the cursor color from the color scheme. Uses hex
        /// color format: "#rrggbb".
        /// </summary>
        [JsonProperty ("cursorColor")]
        public string CursorColor { get; set; }

        /// <summary>
        /// Sets the percentage height of the cursor starting from the bottom. Only works when
        /// cursorShape is set to "vintage". Accepts values from 25-100.
        /// </summary>
        [JsonProperty ("cursorHeight")]
        public long? CursorHeight { get; set; }

        /// <summary>
        /// Sets the shape of the cursor. Possible values:
        /// -"bar" ( ┃, default )
        /// -"emptyBox" ( ▯ )
        /// -"filledBox" ( █ )
        /// -"underscore" ( ▁ )
        /// -"vintage" ( ▃ )
        /// </summary>
        [JsonProperty ("cursorShape", NullValueHandling = NullValueHandling.Ignore)]
        public CursorShape? CursorShape { get; set; }

        /// <summary>
        /// When set to true, enable retro terminal effects. This is an experimental feature, and its
        /// continued existence is not guaranteed.
        /// </summary>
        [JsonProperty ("experimental.retroTerminalEffect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRetroTerminalEffect { get; set; }

        /// <summary>
        /// Name of the font face used in the profile.
        /// </summary>
        [JsonProperty ("fontFace", NullValueHandling = NullValueHandling.Ignore)]
        public string FontFace { get; set; }

        /// <summary>
        /// Size of the font in points.
        /// </summary>
        [JsonProperty ("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public long? FontSize { get; set; }

        /// <summary>
        /// Sets the text color. Overrides "foreground" from the color scheme. Uses hex color format:
        /// "#rrggbb".
        /// </summary>
        [JsonProperty ("foreground", NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// If set to true, the profile will not appear in the list of profiles. This can be used to
        /// hide default profiles and dynamically generated profiles, while leaving them in your
        /// settings file.
        /// </summary>
        [JsonProperty ("hidden", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        /// <summary>
        /// The number of lines above the ones displayed in the window you can scroll back to.
        /// </summary>
        [JsonProperty ("historySize", NullValueHandling = NullValueHandling.Ignore)]
        public long? HistorySize { get; set; }

        /// <summary>
        /// Image file location of the icon used in the profile. Displays within the tab and the
        /// dropdown menu.
        /// </summary>
        [JsonProperty ("icon")]
        public string Icon { get; set; }

        /// <summary>
        /// Sets the padding around the text within the window. Can have three different formats:
        /// -"#" sets the same padding for all sides
        /// -"#, #" sets the same padding for left-right and top-bottom
        /// -"#, #, #, #" sets the padding individually for left, top, right, and bottom.
        /// </summary>
        [JsonProperty ("padding", NullValueHandling = NullValueHandling.Ignore)]
        public string Padding { get; set; }

        /// <summary>
        /// Defines the visibility of the scrollbar.
        /// </summary>
        [JsonProperty ("scrollbarState", NullValueHandling = NullValueHandling.Ignore)]
        public ScrollbarState? ScrollbarState { get; set; }

        /// <summary>
        /// Sets the background color of selected text. Overrides selectionBackground set in the
        /// color scheme. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty ("selectionBackground")]
        public string SelectionBackground { get; set; }

        /// <summary>
        /// When set to true, the window will scroll to the command input line when typing. When set
        /// to false, the window will not scroll when you start typing.
        /// </summary>
        [JsonProperty ("snapOnInput", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapOnInput { get; set; }

        /// <summary>
        /// Stores the name of the profile generator that originated this profile.
        /// </summary>
        [JsonProperty ("source")]
        public string Source { get; set; }

        /// <summary>
        /// The directory the shell starts in when it is loaded.
        /// </summary>
        [JsonProperty ("startingDirectory", NullValueHandling = NullValueHandling.Ignore)]
        public string StartingDirectory { get; set; }

        /// <summary>
        /// When set to true, tabTitle overrides the default title of the tab and any title change
        /// messages from the application will be suppressed. When set to false, tabTitle behaves as
        /// normal.
        /// </summary>
        [JsonProperty ("suppressApplicationTitle", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressApplicationTitle { get; set; }

        /// <summary>
        /// If set, will replace the name as the title to pass to the shell on startup. Some shells
        /// (like bash) may choose to ignore this initial value, while others (cmd, powershell) may
        /// use this value over the lifetime of the application.
        /// </summary>
        [JsonProperty ("tabTitle")]
        public string TabTitle { get; set; }

        /// <summary>
        /// When set to true, the window will have an acrylic background. When set to false, the
        /// window will have a plain, untextured background.
        /// </summary>
        [JsonProperty ("useAcrylic", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseAcrylic { get; set; }

        public override string ToString () {
            var builder = new StringBuilder ();
            builder.AppendLine ($"{nameof(Guid)} = {Guid}");
            builder.AppendLine ($"{nameof(Name)} = {Name}");
            builder.AppendLine ($"{nameof(AcrylicOpacity)} = {AcrylicOpacity}");
            builder.AppendLine ($"{nameof(AntialiasingMode)} = {AntialiasingMode}");
            builder.AppendLine ($"{nameof(Background)} = {Background}");
            builder.AppendLine ($"{nameof(BackgroundImage)} = {BackgroundImage}");
            builder.AppendLine ($"{nameof(BackgroundImageAlignment)} = {BackgroundImageAlignment}");
            builder.AppendLine ($"{nameof(BackgroundImageOpacity)} = {BackgroundImageOpacity}");
            builder.AppendLine ($"{nameof(BackgroundImageStretchMode)} = {BackgroundImageStretchMode}");
            builder.AppendLine ($"{nameof(CloseOnExit)} = {CloseOnExit}");
            builder.AppendLine ($"{nameof(ColorScheme)} = {ColorScheme}");
            builder.AppendLine ($"{nameof(Commandline)} = {Commandline}");
            builder.AppendLine ($"{nameof(CursorColor)} = {CursorColor}");
            builder.AppendLine ($"{nameof(CursorHeight)} = {CursorHeight}");
            builder.AppendLine ($"{nameof(CursorShape)} = {CursorShape}");
            builder.AppendLine ($"{nameof(ExperimentalRetroTerminalEffect)} = {ExperimentalRetroTerminalEffect}");
            builder.AppendLine ($"{nameof(FontFace)} = {FontFace}");
            builder.AppendLine ($"{nameof(FontSize)} = {FontSize}");
            builder.AppendLine ($"{nameof(Foreground)} = {Foreground}");
            builder.AppendLine ($"{nameof(Hidden)} = {Hidden}");
            builder.AppendLine ($"{nameof(HistorySize)} = {HistorySize}");
            builder.AppendLine ($"{nameof(Icon)} = {Icon}");
            builder.AppendLine ($"{nameof(Padding)} = {Padding}");
            builder.AppendLine ($"{nameof(ScrollbarState)} = {ScrollbarState}");
            builder.AppendLine ($"{nameof(SelectionBackground)} = {SelectionBackground}");
            builder.AppendLine ($"{nameof(SnapOnInput)} = {SnapOnInput}");
            builder.AppendLine ($"{nameof(Source)} = {Source}");
            builder.AppendLine ($"{nameof(StartingDirectory)} = {StartingDirectory}");
            builder.AppendLine ($"{nameof(SuppressApplicationTitle)} = {SuppressApplicationTitle}");
            builder.AppendLine ($"{nameof(TabTitle)} = {TabTitle}");
            builder.AppendLine ($"{nameof(UseAcrylic)} = {UseAcrylic}");
            return builder.ToString ();
        }
    }

    /// <summary>
    /// A list of profiles and default settings that apply to all of them
    /// </summary>
    public partial class ProfilesObject {
        /// <summary>
        /// The default settings that apply to every profile.
        /// </summary>
        [JsonProperty ("defaults", NullValueHandling = NullValueHandling.Ignore)]
        public Profile Defaults { get; set; }

        [JsonProperty ("list", NullValueHandling = NullValueHandling.Ignore)]
        public List<ProfileList> List { get; set; }
    }

    /// <summary>
    /// A list of profiles and the properties specific to each.
    ///
    /// Properties specific to a unique profile.
    ///
    /// The default settings that apply to every profile.
    /// </summary>
    public partial class Profile {
        /// <summary>
        /// When useAcrylic is set to true, it sets the transparency of the window for the profile.
        /// Accepts floating point values from 0-1 (default 0.5).
        /// </summary>
        [JsonProperty ("acrylicOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxValueCheckConverter))]
        public double? AcrylicOpacity { get; set; }

        /// <summary>
        /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
        /// "cleartype" and "aliased". Note that changing this setting will require starting a new
        /// terminal instance.
        /// </summary>
        [JsonProperty ("antialiasingMode", NullValueHandling = NullValueHandling.Ignore)]
        public AntialiasingMode? AntialiasingMode { get; set; }

        /// <summary>
        /// Sets the background color of the text. Overrides "background" from the color scheme. Uses
        /// hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty ("background", NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the file location of the image to draw over the window background.
        /// </summary>
        [JsonProperty ("backgroundImage")]
        public string BackgroundImage { get; set; }

        /// <summary>
        /// Sets how the background image aligns to the boundaries of the window. Possible values:
        /// "center", "left", "top", "right", "bottom", "topLeft", "topRight", "bottomLeft",
        /// "bottomRight"
        /// </summary>
        [JsonProperty ("backgroundImageAlignment", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageAlignment? BackgroundImageAlignment { get; set; }

        /// <summary>
        /// Sets the transparency of the background image. Accepts floating point values from 0-1.
        /// </summary>
        [JsonProperty ("backgroundImageOpacity", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxValueCheckConverter))]
        public double? BackgroundImageOpacity { get; set; }

        /// <summary>
        /// Sets how the background image is resized to fill the window.
        /// </summary>
        [JsonProperty ("backgroundImageStretchMode", NullValueHandling = NullValueHandling.Ignore)]
        public BackgroundImageStretchMode? BackgroundImageStretchMode { get; set; }

        /// <summary>
        /// Sets how the profile reacts to termination or failure to launch. Possible values:
        /// -"graceful" (close when exit is typed or the process exits normally)
        /// -"always" (always close)
        /// -"never" (never close).
        /// true and false are accepted as synonyms for "graceful" and "never" respectively.
        /// </summary>
        [JsonProperty ("closeOnExit", NullValueHandling = NullValueHandling.Ignore)]
        public CloseOnExitUnion? CloseOnExit { get; set; }

        /// <summary>
        /// Name of the terminal color scheme to use. Color schemes are defined under "schemes".
        /// </summary>
        [JsonProperty ("colorScheme", NullValueHandling = NullValueHandling.Ignore)]
        public string ColorScheme { get; set; }

        /// <summary>
        /// Executable used in the profile.
        /// </summary>
        [JsonProperty ("commandline", NullValueHandling = NullValueHandling.Ignore)]
        public string Commandline { get; set; }

        /// <summary>
        /// Sets the color of the cursor. Overrides the cursor color from the color scheme. Uses hex
        /// color format: "#rrggbb".
        /// </summary>
        [JsonProperty ("cursorColor")]
        public string CursorColor { get; set; }

        /// <summary>
        /// Sets the percentage height of the cursor starting from the bottom. Only works when
        /// cursorShape is set to "vintage". Accepts values from 25-100.
        /// </summary>
        [JsonProperty ("cursorHeight")]
        public long? CursorHeight { get; set; }

        /// <summary>
        /// Sets the shape of the cursor. Possible values:
        /// -"bar" ( ┃, default )
        /// -"emptyBox" ( ▯ )
        /// -"filledBox" ( █ )
        /// -"underscore" ( ▁ )
        /// -"vintage" ( ▃ )
        /// </summary>
        [JsonProperty ("cursorShape", NullValueHandling = NullValueHandling.Ignore)]
        public CursorShape? CursorShape { get; set; }

        /// <summary>
        /// When set to true, enable retro terminal effects. This is an experimental feature, and its
        /// continued existence is not guaranteed.
        /// </summary>
        [JsonProperty ("experimental.retroTerminalEffect", NullValueHandling = NullValueHandling.Ignore)]
        public bool? ExperimentalRetroTerminalEffect { get; set; }

        /// <summary>
        /// Name of the font face used in the profile.
        /// </summary>
        [JsonProperty ("fontFace", NullValueHandling = NullValueHandling.Ignore)]
        public string FontFace { get; set; }

        /// <summary>
        /// Size of the font in points.
        /// </summary>
        [JsonProperty ("fontSize", NullValueHandling = NullValueHandling.Ignore)]
        public long? FontSize { get; set; }

        /// <summary>
        /// Sets the text color. Overrides "foreground" from the color scheme. Uses hex color format:
        /// "#rrggbb".
        /// </summary>
        [JsonProperty ("foreground", NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// Unique identifier of the profile. Written in registry format:
        /// "{00000000-0000-0000-0000-000000000000}".
        /// </summary>
        [JsonProperty ("guid", NullValueHandling = NullValueHandling.Ignore)]
        public string Guid { get; set; }

        /// <summary>
        /// If set to true, the profile will not appear in the list of profiles. This can be used to
        /// hide default profiles and dynamically generated profiles, while leaving them in your
        /// settings file.
        /// </summary>
        [JsonProperty ("hidden", NullValueHandling = NullValueHandling.Ignore)]
        public bool? Hidden { get; set; }

        /// <summary>
        /// The number of lines above the ones displayed in the window you can scroll back to.
        /// </summary>
        [JsonProperty ("historySize", NullValueHandling = NullValueHandling.Ignore)]
        public long? HistorySize { get; set; }

        /// <summary>
        /// Image file location of the icon used in the profile. Displays within the tab and the
        /// dropdown menu.
        /// </summary>
        [JsonProperty ("icon")]
        public string Icon { get; set; }

        /// <summary>
        /// Name of the profile. Displays in the dropdown menu.
        /// </summary>
        [JsonProperty ("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// Sets the padding around the text within the window. Can have three different formats:
        /// -"#" sets the same padding for all sides
        /// -"#, #" sets the same padding for left-right and top-bottom
        /// -"#, #, #, #" sets the padding individually for left, top, right, and bottom.
        /// </summary>
        [JsonProperty ("padding", NullValueHandling = NullValueHandling.Ignore)]
        public string Padding { get; set; }

        /// <summary>
        /// Defines the visibility of the scrollbar.
        /// </summary>
        [JsonProperty ("scrollbarState", NullValueHandling = NullValueHandling.Ignore)]
        public ScrollbarState? ScrollbarState { get; set; }

        /// <summary>
        /// Sets the background color of selected text. Overrides selectionBackground set in the
        /// color scheme. Uses hex color format: "#rrggbb".
        /// </summary>
        [JsonProperty ("selectionBackground")]
        public string SelectionBackground { get; set; }

        /// <summary>
        /// When set to true, the window will scroll to the command input line when typing. When set
        /// to false, the window will not scroll when you start typing.
        /// </summary>
        [JsonProperty ("snapOnInput", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SnapOnInput { get; set; }

        /// <summary>
        /// Stores the name of the profile generator that originated this profile.
        /// </summary>
        [JsonProperty ("source")]
        public string Source { get; set; }

        /// <summary>
        /// The directory the shell starts in when it is loaded.
        /// </summary>
        [JsonProperty ("startingDirectory", NullValueHandling = NullValueHandling.Ignore)]
        public string StartingDirectory { get; set; }

        /// <summary>
        /// When set to true, tabTitle overrides the default title of the tab and any title change
        /// messages from the application will be suppressed. When set to false, tabTitle behaves as
        /// normal.
        /// </summary>
        [JsonProperty ("suppressApplicationTitle", NullValueHandling = NullValueHandling.Ignore)]
        public bool? SuppressApplicationTitle { get; set; }

        /// <summary>
        /// If set, will replace the name as the title to pass to the shell on startup. Some shells
        /// (like bash) may choose to ignore this initial value, while others (cmd, powershell) may
        /// use this value over the lifetime of the application.
        /// </summary>
        [JsonProperty ("tabTitle")]
        public string TabTitle { get; set; }

        /// <summary>
        /// When set to true, the window will have an acrylic background. When set to false, the
        /// window will have a plain, untextured background.
        /// </summary>
        [JsonProperty ("useAcrylic", NullValueHandling = NullValueHandling.Ignore)]
        public bool? UseAcrylic { get; set; }
    }

    /// <summary>
    /// Properties are specific to each color scheme. ColorTool is a great tool you can use to
    /// create and explore new color schemes. All colors use hex color format.
    /// </summary>
    public partial class SchemeList {
        /// <summary>
        /// Sets the background color of the color scheme.
        /// </summary>
        [JsonProperty ("background", NullValueHandling = NullValueHandling.Ignore)]
        public string Background { get; set; }

        /// <summary>
        /// Sets the color used as ANSI black.
        /// </summary>
        [JsonProperty ("black", NullValueHandling = NullValueHandling.Ignore)]
        public string Black { get; set; }

        /// <summary>
        /// Sets the color used as ANSI blue.
        /// </summary>
        [JsonProperty ("blue", NullValueHandling = NullValueHandling.Ignore)]
        public string Blue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright black.
        /// </summary>
        [JsonProperty ("brightBlack", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightBlack { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright blue.
        /// </summary>
        [JsonProperty ("brightBlue", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightBlue { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright cyan.
        /// </summary>
        [JsonProperty ("brightCyan", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightCyan { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright green.
        /// </summary>
        [JsonProperty ("brightGreen", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightGreen { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright purple.
        /// </summary>
        [JsonProperty ("brightPurple", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightPurple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright red.
        /// </summary>
        [JsonProperty ("brightRed", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightRed { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright white.
        /// </summary>
        [JsonProperty ("brightWhite", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightWhite { get; set; }

        /// <summary>
        /// Sets the color used as ANSI bright yellow.
        /// </summary>
        [JsonProperty ("brightYellow", NullValueHandling = NullValueHandling.Ignore)]
        public string BrightYellow { get; set; }

        /// <summary>
        /// Sets the cursor color of the color scheme.
        /// </summary>
        [JsonProperty ("cursorColor", NullValueHandling = NullValueHandling.Ignore)]
        public string CursorColor { get; set; }

        /// <summary>
        /// Sets the color used as ANSI cyan.
        /// </summary>
        [JsonProperty ("cyan", NullValueHandling = NullValueHandling.Ignore)]
        public string Cyan { get; set; }

        /// <summary>
        /// Sets the foreground color of the color scheme.
        /// </summary>
        [JsonProperty ("foreground", NullValueHandling = NullValueHandling.Ignore)]
        public string Foreground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI green.
        /// </summary>
        [JsonProperty ("green", NullValueHandling = NullValueHandling.Ignore)]
        public string Green { get; set; }

        /// <summary>
        /// Name of the color scheme.
        /// </summary>
        [JsonProperty ("name", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter (typeof (MinMaxLengthCheckConverter))]
        public string Name { get; set; }

        /// <summary>
        /// Sets the color used as ANSI purple.
        /// </summary>
        [JsonProperty ("purple", NullValueHandling = NullValueHandling.Ignore)]
        public string Purple { get; set; }

        /// <summary>
        /// Sets the color used as ANSI red.
        /// </summary>
        [JsonProperty ("red", NullValueHandling = NullValueHandling.Ignore)]
        public string Red { get; set; }

        /// <summary>
        /// Sets the selection background color of the color scheme.
        /// </summary>
        [JsonProperty ("selectionBackground", NullValueHandling = NullValueHandling.Ignore)]
        public string SelectionBackground { get; set; }

        /// <summary>
        /// Sets the color used as ANSI white.
        /// </summary>
        [JsonProperty ("white", NullValueHandling = NullValueHandling.Ignore)]
        public string White { get; set; }

        /// <summary>
        /// Sets the color used as ANSI yellow.
        /// </summary>
        [JsonProperty ("yellow", NullValueHandling = NullValueHandling.Ignore)]
        public string Yellow { get; set; }
    }

    public enum DynamicProfileSource { WindowsTerminalAzure, WindowsTerminalPowershellCore, WindowsTerminalWsl }

    /// <summary>
    /// The action to execute
    /// </summary>
    public enum CommandEnum { AdjustFontSize, ClosePane, CloseTab, CloseWindow, Copy, DuplicateTab, Find, MoveFocus, NewTab, NextTab, OpenNewTabDropdown, OpenSettings, Paste, PrevTab, ResetFontSize, ResizePane, ScrollDown, ScrollDownPage, ScrollUp, ScrollUpPage, SplitPane, SwitchToTab, ToggleFullscreen, Unbound }

    /// <summary>
    /// The action to execute
    /// </summary>
    public enum ActionEnum { AdjustFontSize, ClosePane, CloseTab, CloseWindow, Copy, DuplicateTab, Find, MoveFocus, NewTab, NextTab, OpenNewTabDropdown, OpenSettings, Paste, PrevTab, ResetFontSize, ResizePane, ScrollDown, ScrollDownPage, ScrollUp, ScrollUpPage, SplitPane, SwitchToTab, ToggleFullscreen, Unbound }

    /// <summary>
    /// The direction to move focus in, between panes
    ///
    /// The direction to move the pane separator in
    /// </summary>
    public enum Direction { Down, Left, Right, Up }

    /// <summary>
    /// The orientation to split the pane in. Possible values:
    /// -"auto" (splits pane based on remaining space)
    /// -"horizontal" (think [-])
    /// -"vertical" (think [|])
    /// </summary>
    public enum SplitState { Auto, Horizontal, Vertical }

    /// <summary>
    /// Defines whether the Terminal will launch as maximized or not.
    /// </summary>
    public enum LaunchMode { Default, Maximized }

    /// <summary>
    /// Controls how text is antialiased in the renderer. Possible values are "grayscale",
    /// "cleartype" and "aliased". Note that changing this setting will require starting a new
    /// terminal instance.
    /// </summary>
    public enum AntialiasingMode { Aliased, Cleartype, Grayscale }

    /// <summary>
    /// Sets how the background image aligns to the boundaries of the window. Possible values:
    /// "center", "left", "top", "right", "bottom", "topLeft", "topRight", "bottomLeft",
    /// "bottomRight"
    /// </summary>
    public enum BackgroundImageAlignment { Bottom, BottomLeft, BottomRight, Center, Left, Right, Top, TopLeft, TopRight }

    /// <summary>
    /// Sets how the background image is resized to fill the window.
    /// </summary>
    public enum BackgroundImageStretchMode { Fill, None, Uniform, UniformToFill }

    public enum CloseOnExitEnum { Always, Graceful, Never }

    /// <summary>
    /// Sets the shape of the cursor. Possible values:
    /// -"bar" ( ┃, default )
    /// -"emptyBox" ( ▯ )
    /// -"filledBox" ( █ )
    /// -"underscore" ( ▁ )
    /// -"vintage" ( ▃ )
    /// </summary>
    public enum CursorShape { Bar, EmptyBox, FilledBox, Underscore, Vintage }

    /// <summary>
    /// Defines the visibility of the scrollbar.
    /// </summary>
    public enum ScrollbarState { Hidden, Visible }

    /// <summary>
    /// Sets the width of the tabs. Possible values include:
    /// -"equal" sizes each tab to the same width
    /// -"titleLength" sizes each tab to the length of its title
    /// </summary>
    public enum TabWidthMode { Equal, TitleLength }

    /// <summary>
    /// Sets the theme of the application. The special value "system" refers to the active
    /// Windows system theme.
    /// </summary>
    public enum Theme { Dark, Light, System }

    /// <summary>
    /// The action executed when the associated key bindings are pressed.
    /// </summary>
    public partial struct Command {
        public Action Action;
        public CommandEnum? Enum;

        public static implicit operator Command (Action Action) => new Command { Action = Action };
        public static implicit operator Command (CommandEnum Enum) => new Command { Enum = Enum };
        public bool IsNull => Action == null && Enum == null;
    }

    /// <summary>
    /// Defines the key combinations used to call the command. It must be composed of...
    /// -any number of modifiers (ctrl/alt/shift)
    /// -a non-modifier key
    /// </summary>
    public partial struct Keys {
        public string String;
        public List<string> StringArray;

        public static implicit operator Keys (string String) => new Keys { String = String };
        public static implicit operator Keys (List<string> StringArray) => new Keys { StringArray = StringArray };
    }

    /// <summary>
    /// Sets how the profile reacts to termination or failure to launch. Possible values:
    /// -"graceful" (close when exit is typed or the process exits normally)
    /// -"always" (always close)
    /// -"never" (never close).
    /// true and false are accepted as synonyms for "graceful" and "never" respectively.
    /// </summary>
    public partial struct CloseOnExitUnion {
        public bool? Bool;
        public CloseOnExitEnum? Enum;

        public static implicit operator CloseOnExitUnion (bool Bool) => new CloseOnExitUnion { Bool = Bool };
        public static implicit operator CloseOnExitUnion (CloseOnExitEnum Enum) => new CloseOnExitUnion { Enum = Enum };
    }

    public partial struct Profiles {
        public List<ProfileList> ProfileListArray;
        public ProfilesObject ProfilesObject;

        public static implicit operator Profiles (List<ProfileList> ProfileListArray) => new Profiles { ProfileListArray = ProfileListArray };
        public static implicit operator Profiles (ProfilesObject ProfilesObject) => new Profiles { ProfilesObject = ProfilesObject };
    }

    /// <summary>
    /// The number of rows to scroll at a time with the mouse wheel. This will override the
    /// system setting if the value is not zero or "system".
    /// </summary>
    public partial struct RowsToScroll {
        public long? Integer;
        public string String;

        public static implicit operator RowsToScroll (long Integer) => new RowsToScroll { Integer = Integer };
        public static implicit operator RowsToScroll (string String) => new RowsToScroll { String = String };
    }

    public partial class TerminalConfig {
        public static TerminalConfig FromJson (string json) => JsonConvert.DeserializeObject<TerminalConfig> (json, SSHMan.Converter.Settings);
    }

    public static class Serialize {
        public static string ToJson (this TerminalConfig self) => JsonConvert.SerializeObject (self, SSHMan.Converter.Settings);
    }

    internal static class Converter {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            NullValueHandling = NullValueHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters = {
                DynamicProfileSourceConverter.Singleton,
                CommandConverter.Singleton,
                ActionEnumConverter.Singleton,
                DirectionConverter.Singleton,
                SplitStateConverter.Singleton,
                CommandEnumConverter.Singleton,
                KeysConverter.Singleton,
                LaunchModeConverter.Singleton,
                ProfilesConverter.Singleton,
                AntialiasingModeConverter.Singleton,
                BackgroundImageAlignmentConverter.Singleton,
                BackgroundImageStretchModeConverter.Singleton,
                CloseOnExitUnionConverter.Singleton,
                CloseOnExitEnumConverter.Singleton,
                CursorShapeConverter.Singleton,
                ScrollbarStateConverter.Singleton,
                RowsToScrollConverter.Singleton,
                TabWidthModeConverter.Singleton,
                ThemeConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
            Formatting = Formatting.Indented
        };
    }

    internal class DynamicProfileSourceConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (DynamicProfileSource) || t == typeof (DynamicProfileSource?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "Windows.Terminal.Azure":
                    return DynamicProfileSource.WindowsTerminalAzure;
                case "Windows.Terminal.PowershellCore":
                    return DynamicProfileSource.WindowsTerminalPowershellCore;
                case "Windows.Terminal.Wsl":
                    return DynamicProfileSource.WindowsTerminalWsl;
            }
            throw new Exception ("Cannot unmarshal type DynamicProfileSource");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (DynamicProfileSource) untypedValue;
            switch (value) {
                case DynamicProfileSource.WindowsTerminalAzure:
                    serializer.Serialize (writer, "Windows.Terminal.Azure");
                    return;
                case DynamicProfileSource.WindowsTerminalPowershellCore:
                    serializer.Serialize (writer, "Windows.Terminal.PowershellCore");
                    return;
                case DynamicProfileSource.WindowsTerminalWsl:
                    serializer.Serialize (writer, "Windows.Terminal.Wsl");
                    return;
            }
            throw new Exception ("Cannot marshal type DynamicProfileSource");
        }

        public static readonly DynamicProfileSourceConverter Singleton = new DynamicProfileSourceConverter ();
    }

    internal class CommandConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (Command) || t == typeof (Command?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            switch (reader.TokenType) {
                case JsonToken.Null:
                    return new Command { };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string> (reader);
                    switch (stringValue) {
                        case "adjustFontSize":
                            return new Command { Enum = CommandEnum.AdjustFontSize };
                        case "closePane":
                            return new Command { Enum = CommandEnum.ClosePane };
                        case "closeTab":
                            return new Command { Enum = CommandEnum.CloseTab };
                        case "closeWindow":
                            return new Command { Enum = CommandEnum.CloseWindow };
                        case "copy":
                            return new Command { Enum = CommandEnum.Copy };
                        case "duplicateTab":
                            return new Command { Enum = CommandEnum.DuplicateTab };
                        case "find":
                            return new Command { Enum = CommandEnum.Find };
                        case "moveFocus":
                            return new Command { Enum = CommandEnum.MoveFocus };
                        case "newTab":
                            return new Command { Enum = CommandEnum.NewTab };
                        case "nextTab":
                            return new Command { Enum = CommandEnum.NextTab };
                        case "openNewTabDropdown":
                            return new Command { Enum = CommandEnum.OpenNewTabDropdown };
                        case "openSettings":
                            return new Command { Enum = CommandEnum.OpenSettings };
                        case "paste":
                            return new Command { Enum = CommandEnum.Paste };
                        case "prevTab":
                            return new Command { Enum = CommandEnum.PrevTab };
                        case "resetFontSize":
                            return new Command { Enum = CommandEnum.ResetFontSize };
                        case "resizePane":
                            return new Command { Enum = CommandEnum.ResizePane };
                        case "scrollDown":
                            return new Command { Enum = CommandEnum.ScrollDown };
                        case "scrollDownPage":
                            return new Command { Enum = CommandEnum.ScrollDownPage };
                        case "scrollUp":
                            return new Command { Enum = CommandEnum.ScrollUp };
                        case "scrollUpPage":
                            return new Command { Enum = CommandEnum.ScrollUpPage };
                        case "splitPane":
                            return new Command { Enum = CommandEnum.SplitPane };
                        case "switchToTab":
                            return new Command { Enum = CommandEnum.SwitchToTab };
                        case "toggleFullscreen":
                            return new Command { Enum = CommandEnum.ToggleFullscreen };
                        case "unbound":
                            return new Command { Enum = CommandEnum.Unbound };
                    }
                    break;
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Action> (reader);
                    return new Command { Action = objectValue };
            }
            throw new Exception ("Cannot unmarshal type Command");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (Command) untypedValue;
            if (value.IsNull) {
                serializer.Serialize (writer, null);
                return;
            }
            if (value.Enum != null) {
                switch (value.Enum) {
                    case CommandEnum.AdjustFontSize:
                        serializer.Serialize (writer, "adjustFontSize");
                        return;
                    case CommandEnum.ClosePane:
                        serializer.Serialize (writer, "closePane");
                        return;
                    case CommandEnum.CloseTab:
                        serializer.Serialize (writer, "closeTab");
                        return;
                    case CommandEnum.CloseWindow:
                        serializer.Serialize (writer, "closeWindow");
                        return;
                    case CommandEnum.Copy:
                        serializer.Serialize (writer, "copy");
                        return;
                    case CommandEnum.DuplicateTab:
                        serializer.Serialize (writer, "duplicateTab");
                        return;
                    case CommandEnum.Find:
                        serializer.Serialize (writer, "find");
                        return;
                    case CommandEnum.MoveFocus:
                        serializer.Serialize (writer, "moveFocus");
                        return;
                    case CommandEnum.NewTab:
                        serializer.Serialize (writer, "newTab");
                        return;
                    case CommandEnum.NextTab:
                        serializer.Serialize (writer, "nextTab");
                        return;
                    case CommandEnum.OpenNewTabDropdown:
                        serializer.Serialize (writer, "openNewTabDropdown");
                        return;
                    case CommandEnum.OpenSettings:
                        serializer.Serialize (writer, "openSettings");
                        return;
                    case CommandEnum.Paste:
                        serializer.Serialize (writer, "paste");
                        return;
                    case CommandEnum.PrevTab:
                        serializer.Serialize (writer, "prevTab");
                        return;
                    case CommandEnum.ResetFontSize:
                        serializer.Serialize (writer, "resetFontSize");
                        return;
                    case CommandEnum.ResizePane:
                        serializer.Serialize (writer, "resizePane");
                        return;
                    case CommandEnum.ScrollDown:
                        serializer.Serialize (writer, "scrollDown");
                        return;
                    case CommandEnum.ScrollDownPage:
                        serializer.Serialize (writer, "scrollDownPage");
                        return;
                    case CommandEnum.ScrollUp:
                        serializer.Serialize (writer, "scrollUp");
                        return;
                    case CommandEnum.ScrollUpPage:
                        serializer.Serialize (writer, "scrollUpPage");
                        return;
                    case CommandEnum.SplitPane:
                        serializer.Serialize (writer, "splitPane");
                        return;
                    case CommandEnum.SwitchToTab:
                        serializer.Serialize (writer, "switchToTab");
                        return;
                    case CommandEnum.ToggleFullscreen:
                        serializer.Serialize (writer, "toggleFullscreen");
                        return;
                    case CommandEnum.Unbound:
                        serializer.Serialize (writer, "unbound");
                        return;
                }
            }
            if (value.Action != null) {
                serializer.Serialize (writer, value.Action);
                return;
            }
            throw new Exception ("Cannot marshal type Command");
        }

        public static readonly CommandConverter Singleton = new CommandConverter ();
    }

    internal class ActionEnumConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (ActionEnum) || t == typeof (ActionEnum?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "adjustFontSize":
                    return ActionEnum.AdjustFontSize;
                case "closePane":
                    return ActionEnum.ClosePane;
                case "closeTab":
                    return ActionEnum.CloseTab;
                case "closeWindow":
                    return ActionEnum.CloseWindow;
                case "copy":
                    return ActionEnum.Copy;
                case "duplicateTab":
                    return ActionEnum.DuplicateTab;
                case "find":
                    return ActionEnum.Find;
                case "moveFocus":
                    return ActionEnum.MoveFocus;
                case "newTab":
                    return ActionEnum.NewTab;
                case "nextTab":
                    return ActionEnum.NextTab;
                case "openNewTabDropdown":
                    return ActionEnum.OpenNewTabDropdown;
                case "openSettings":
                    return ActionEnum.OpenSettings;
                case "paste":
                    return ActionEnum.Paste;
                case "prevTab":
                    return ActionEnum.PrevTab;
                case "resetFontSize":
                    return ActionEnum.ResetFontSize;
                case "resizePane":
                    return ActionEnum.ResizePane;
                case "scrollDown":
                    return ActionEnum.ScrollDown;
                case "scrollDownPage":
                    return ActionEnum.ScrollDownPage;
                case "scrollUp":
                    return ActionEnum.ScrollUp;
                case "scrollUpPage":
                    return ActionEnum.ScrollUpPage;
                case "splitPane":
                    return ActionEnum.SplitPane;
                case "switchToTab":
                    return ActionEnum.SwitchToTab;
                case "toggleFullscreen":
                    return ActionEnum.ToggleFullscreen;
                case "unbound":
                    return ActionEnum.Unbound;
            }
            throw new Exception ("Cannot unmarshal type ActionEnum");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (ActionEnum) untypedValue;
            switch (value) {
                case ActionEnum.AdjustFontSize:
                    serializer.Serialize (writer, "adjustFontSize");
                    return;
                case ActionEnum.ClosePane:
                    serializer.Serialize (writer, "closePane");
                    return;
                case ActionEnum.CloseTab:
                    serializer.Serialize (writer, "closeTab");
                    return;
                case ActionEnum.CloseWindow:
                    serializer.Serialize (writer, "closeWindow");
                    return;
                case ActionEnum.Copy:
                    serializer.Serialize (writer, "copy");
                    return;
                case ActionEnum.DuplicateTab:
                    serializer.Serialize (writer, "duplicateTab");
                    return;
                case ActionEnum.Find:
                    serializer.Serialize (writer, "find");
                    return;
                case ActionEnum.MoveFocus:
                    serializer.Serialize (writer, "moveFocus");
                    return;
                case ActionEnum.NewTab:
                    serializer.Serialize (writer, "newTab");
                    return;
                case ActionEnum.NextTab:
                    serializer.Serialize (writer, "nextTab");
                    return;
                case ActionEnum.OpenNewTabDropdown:
                    serializer.Serialize (writer, "openNewTabDropdown");
                    return;
                case ActionEnum.OpenSettings:
                    serializer.Serialize (writer, "openSettings");
                    return;
                case ActionEnum.Paste:
                    serializer.Serialize (writer, "paste");
                    return;
                case ActionEnum.PrevTab:
                    serializer.Serialize (writer, "prevTab");
                    return;
                case ActionEnum.ResetFontSize:
                    serializer.Serialize (writer, "resetFontSize");
                    return;
                case ActionEnum.ResizePane:
                    serializer.Serialize (writer, "resizePane");
                    return;
                case ActionEnum.ScrollDown:
                    serializer.Serialize (writer, "scrollDown");
                    return;
                case ActionEnum.ScrollDownPage:
                    serializer.Serialize (writer, "scrollDownPage");
                    return;
                case ActionEnum.ScrollUp:
                    serializer.Serialize (writer, "scrollUp");
                    return;
                case ActionEnum.ScrollUpPage:
                    serializer.Serialize (writer, "scrollUpPage");
                    return;
                case ActionEnum.SplitPane:
                    serializer.Serialize (writer, "splitPane");
                    return;
                case ActionEnum.SwitchToTab:
                    serializer.Serialize (writer, "switchToTab");
                    return;
                case ActionEnum.ToggleFullscreen:
                    serializer.Serialize (writer, "toggleFullscreen");
                    return;
                case ActionEnum.Unbound:
                    serializer.Serialize (writer, "unbound");
                    return;
            }
            throw new Exception ("Cannot marshal type ActionEnum");
        }

        public static readonly ActionEnumConverter Singleton = new ActionEnumConverter ();
    }

    internal class DirectionConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (Direction) || t == typeof (Direction?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "down":
                    return Direction.Down;
                case "left":
                    return Direction.Left;
                case "right":
                    return Direction.Right;
                case "up":
                    return Direction.Up;
            }
            throw new Exception ("Cannot unmarshal type Direction");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (Direction) untypedValue;
            switch (value) {
                case Direction.Down:
                    serializer.Serialize (writer, "down");
                    return;
                case Direction.Left:
                    serializer.Serialize (writer, "left");
                    return;
                case Direction.Right:
                    serializer.Serialize (writer, "right");
                    return;
                case Direction.Up:
                    serializer.Serialize (writer, "up");
                    return;
            }
            throw new Exception ("Cannot marshal type Direction");
        }

        public static readonly DirectionConverter Singleton = new DirectionConverter ();
    }

    internal class SplitStateConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (SplitState) || t == typeof (SplitState?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "auto":
                    return SplitState.Auto;
                case "horizontal":
                    return SplitState.Horizontal;
                case "vertical":
                    return SplitState.Vertical;
            }
            throw new Exception ("Cannot unmarshal type SplitState");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (SplitState) untypedValue;
            switch (value) {
                case SplitState.Auto:
                    serializer.Serialize (writer, "auto");
                    return;
                case SplitState.Horizontal:
                    serializer.Serialize (writer, "horizontal");
                    return;
                case SplitState.Vertical:
                    serializer.Serialize (writer, "vertical");
                    return;
            }
            throw new Exception ("Cannot marshal type SplitState");
        }

        public static readonly SplitStateConverter Singleton = new SplitStateConverter ();
    }

    internal class CommandEnumConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (CommandEnum) || t == typeof (CommandEnum?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "adjustFontSize":
                    return CommandEnum.AdjustFontSize;
                case "closePane":
                    return CommandEnum.ClosePane;
                case "closeTab":
                    return CommandEnum.CloseTab;
                case "closeWindow":
                    return CommandEnum.CloseWindow;
                case "copy":
                    return CommandEnum.Copy;
                case "duplicateTab":
                    return CommandEnum.DuplicateTab;
                case "find":
                    return CommandEnum.Find;
                case "moveFocus":
                    return CommandEnum.MoveFocus;
                case "newTab":
                    return CommandEnum.NewTab;
                case "nextTab":
                    return CommandEnum.NextTab;
                case "openNewTabDropdown":
                    return CommandEnum.OpenNewTabDropdown;
                case "openSettings":
                    return CommandEnum.OpenSettings;
                case "paste":
                    return CommandEnum.Paste;
                case "prevTab":
                    return CommandEnum.PrevTab;
                case "resetFontSize":
                    return CommandEnum.ResetFontSize;
                case "resizePane":
                    return CommandEnum.ResizePane;
                case "scrollDown":
                    return CommandEnum.ScrollDown;
                case "scrollDownPage":
                    return CommandEnum.ScrollDownPage;
                case "scrollUp":
                    return CommandEnum.ScrollUp;
                case "scrollUpPage":
                    return CommandEnum.ScrollUpPage;
                case "splitPane":
                    return CommandEnum.SplitPane;
                case "switchToTab":
                    return CommandEnum.SwitchToTab;
                case "toggleFullscreen":
                    return CommandEnum.ToggleFullscreen;
                case "unbound":
                    return CommandEnum.Unbound;
            }
            throw new Exception ("Cannot unmarshal type CommandEnum");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (CommandEnum) untypedValue;
            switch (value) {
                case CommandEnum.AdjustFontSize:
                    serializer.Serialize (writer, "adjustFontSize");
                    return;
                case CommandEnum.ClosePane:
                    serializer.Serialize (writer, "closePane");
                    return;
                case CommandEnum.CloseTab:
                    serializer.Serialize (writer, "closeTab");
                    return;
                case CommandEnum.CloseWindow:
                    serializer.Serialize (writer, "closeWindow");
                    return;
                case CommandEnum.Copy:
                    serializer.Serialize (writer, "copy");
                    return;
                case CommandEnum.DuplicateTab:
                    serializer.Serialize (writer, "duplicateTab");
                    return;
                case CommandEnum.Find:
                    serializer.Serialize (writer, "find");
                    return;
                case CommandEnum.MoveFocus:
                    serializer.Serialize (writer, "moveFocus");
                    return;
                case CommandEnum.NewTab:
                    serializer.Serialize (writer, "newTab");
                    return;
                case CommandEnum.NextTab:
                    serializer.Serialize (writer, "nextTab");
                    return;
                case CommandEnum.OpenNewTabDropdown:
                    serializer.Serialize (writer, "openNewTabDropdown");
                    return;
                case CommandEnum.OpenSettings:
                    serializer.Serialize (writer, "openSettings");
                    return;
                case CommandEnum.Paste:
                    serializer.Serialize (writer, "paste");
                    return;
                case CommandEnum.PrevTab:
                    serializer.Serialize (writer, "prevTab");
                    return;
                case CommandEnum.ResetFontSize:
                    serializer.Serialize (writer, "resetFontSize");
                    return;
                case CommandEnum.ResizePane:
                    serializer.Serialize (writer, "resizePane");
                    return;
                case CommandEnum.ScrollDown:
                    serializer.Serialize (writer, "scrollDown");
                    return;
                case CommandEnum.ScrollDownPage:
                    serializer.Serialize (writer, "scrollDownPage");
                    return;
                case CommandEnum.ScrollUp:
                    serializer.Serialize (writer, "scrollUp");
                    return;
                case CommandEnum.ScrollUpPage:
                    serializer.Serialize (writer, "scrollUpPage");
                    return;
                case CommandEnum.SplitPane:
                    serializer.Serialize (writer, "splitPane");
                    return;
                case CommandEnum.SwitchToTab:
                    serializer.Serialize (writer, "switchToTab");
                    return;
                case CommandEnum.ToggleFullscreen:
                    serializer.Serialize (writer, "toggleFullscreen");
                    return;
                case CommandEnum.Unbound:
                    serializer.Serialize (writer, "unbound");
                    return;
            }
            throw new Exception ("Cannot marshal type CommandEnum");
        }

        public static readonly CommandEnumConverter Singleton = new CommandEnumConverter ();
    }

    internal class KeysConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (Keys) || t == typeof (Keys?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            switch (reader.TokenType) {
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string> (reader);
                    return new Keys { String = stringValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<string>> (reader);
                    return new Keys { StringArray = arrayValue };
            }
            throw new Exception ("Cannot unmarshal type Keys");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (Keys) untypedValue;
            if (value.String != null) {
                serializer.Serialize (writer, value.String);
                return;
            }
            if (value.StringArray != null) {
                serializer.Serialize (writer, value.StringArray);
                return;
            }
            throw new Exception ("Cannot marshal type Keys");
        }

        public static readonly KeysConverter Singleton = new KeysConverter ();
    }

    internal class LaunchModeConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (LaunchMode) || t == typeof (LaunchMode?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "default":
                    return LaunchMode.Default;
                case "maximized":
                    return LaunchMode.Maximized;
            }
            throw new Exception ("Cannot unmarshal type LaunchMode");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (LaunchMode) untypedValue;
            switch (value) {
                case LaunchMode.Default:
                    serializer.Serialize (writer, "default");
                    return;
                case LaunchMode.Maximized:
                    serializer.Serialize (writer, "maximized");
                    return;
            }
            throw new Exception ("Cannot marshal type LaunchMode");
        }

        public static readonly LaunchModeConverter Singleton = new LaunchModeConverter ();
    }

    internal class ProfilesConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (Profiles) || t == typeof (Profiles?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            switch (reader.TokenType) {
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<ProfilesObject> (reader);
                    return new Profiles { ProfilesObject = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<ProfileList>> (reader);
                    return new Profiles { ProfileListArray = arrayValue };
            }
            throw new Exception ("Cannot unmarshal type Profiles");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (Profiles) untypedValue;
            if (value.ProfileListArray != null) {
                serializer.Serialize (writer, value.ProfileListArray);
                return;
            }
            if (value.ProfilesObject != null) {
                serializer.Serialize (writer, value.ProfilesObject);
                return;
            }
            throw new Exception ("Cannot marshal type Profiles");
        }

        public static readonly ProfilesConverter Singleton = new ProfilesConverter ();
    }

    internal class MinMaxValueCheckConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (double) || t == typeof (double?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<double> (reader);
            if (value >= 0 && value <= 1) {
                return value;
            }
            throw new Exception ("Cannot unmarshal type double");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (double) untypedValue;
            if (value >= 0 && value <= 1) {
                serializer.Serialize (writer, value);
                return;
            }
            throw new Exception ("Cannot marshal type double");
        }

        public static readonly MinMaxValueCheckConverter Singleton = new MinMaxValueCheckConverter ();
    }

    internal class AntialiasingModeConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (AntialiasingMode) || t == typeof (AntialiasingMode?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "aliased":
                    return AntialiasingMode.Aliased;
                case "cleartype":
                    return AntialiasingMode.Cleartype;
                case "grayscale":
                    return AntialiasingMode.Grayscale;
            }
            throw new Exception ("Cannot unmarshal type AntialiasingMode");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (AntialiasingMode) untypedValue;
            switch (value) {
                case AntialiasingMode.Aliased:
                    serializer.Serialize (writer, "aliased");
                    return;
                case AntialiasingMode.Cleartype:
                    serializer.Serialize (writer, "cleartype");
                    return;
                case AntialiasingMode.Grayscale:
                    serializer.Serialize (writer, "grayscale");
                    return;
            }
            throw new Exception ("Cannot marshal type AntialiasingMode");
        }

        public static readonly AntialiasingModeConverter Singleton = new AntialiasingModeConverter ();
    }

    internal class BackgroundImageAlignmentConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (BackgroundImageAlignment) || t == typeof (BackgroundImageAlignment?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "bottom":
                    return BackgroundImageAlignment.Bottom;
                case "bottomLeft":
                    return BackgroundImageAlignment.BottomLeft;
                case "bottomRight":
                    return BackgroundImageAlignment.BottomRight;
                case "center":
                    return BackgroundImageAlignment.Center;
                case "left":
                    return BackgroundImageAlignment.Left;
                case "right":
                    return BackgroundImageAlignment.Right;
                case "top":
                    return BackgroundImageAlignment.Top;
                case "topLeft":
                    return BackgroundImageAlignment.TopLeft;
                case "topRight":
                    return BackgroundImageAlignment.TopRight;
            }
            throw new Exception ("Cannot unmarshal type BackgroundImageAlignment");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (BackgroundImageAlignment) untypedValue;
            switch (value) {
                case BackgroundImageAlignment.Bottom:
                    serializer.Serialize (writer, "bottom");
                    return;
                case BackgroundImageAlignment.BottomLeft:
                    serializer.Serialize (writer, "bottomLeft");
                    return;
                case BackgroundImageAlignment.BottomRight:
                    serializer.Serialize (writer, "bottomRight");
                    return;
                case BackgroundImageAlignment.Center:
                    serializer.Serialize (writer, "center");
                    return;
                case BackgroundImageAlignment.Left:
                    serializer.Serialize (writer, "left");
                    return;
                case BackgroundImageAlignment.Right:
                    serializer.Serialize (writer, "right");
                    return;
                case BackgroundImageAlignment.Top:
                    serializer.Serialize (writer, "top");
                    return;
                case BackgroundImageAlignment.TopLeft:
                    serializer.Serialize (writer, "topLeft");
                    return;
                case BackgroundImageAlignment.TopRight:
                    serializer.Serialize (writer, "topRight");
                    return;
            }
            throw new Exception ("Cannot marshal type BackgroundImageAlignment");
        }

        public static readonly BackgroundImageAlignmentConverter Singleton = new BackgroundImageAlignmentConverter ();
    }

    internal class BackgroundImageStretchModeConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (BackgroundImageStretchMode) || t == typeof (BackgroundImageStretchMode?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "fill":
                    return BackgroundImageStretchMode.Fill;
                case "none":
                    return BackgroundImageStretchMode.None;
                case "uniform":
                    return BackgroundImageStretchMode.Uniform;
                case "uniformToFill":
                    return BackgroundImageStretchMode.UniformToFill;
            }
            throw new Exception ("Cannot unmarshal type BackgroundImageStretchMode");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (BackgroundImageStretchMode) untypedValue;
            switch (value) {
                case BackgroundImageStretchMode.Fill:
                    serializer.Serialize (writer, "fill");
                    return;
                case BackgroundImageStretchMode.None:
                    serializer.Serialize (writer, "none");
                    return;
                case BackgroundImageStretchMode.Uniform:
                    serializer.Serialize (writer, "uniform");
                    return;
                case BackgroundImageStretchMode.UniformToFill:
                    serializer.Serialize (writer, "uniformToFill");
                    return;
            }
            throw new Exception ("Cannot marshal type BackgroundImageStretchMode");
        }

        public static readonly BackgroundImageStretchModeConverter Singleton = new BackgroundImageStretchModeConverter ();
    }

    internal class CloseOnExitUnionConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (CloseOnExitUnion) || t == typeof (CloseOnExitUnion?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            switch (reader.TokenType) {
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool> (reader);
                    return new CloseOnExitUnion { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string> (reader);
                    switch (stringValue) {
                        case "always":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Always };
                        case "graceful":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Graceful };
                        case "never":
                            return new CloseOnExitUnion { Enum = CloseOnExitEnum.Never };
                    }
                    break;
            }
            throw new Exception ("Cannot unmarshal type CloseOnExitUnion");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (CloseOnExitUnion) untypedValue;
            if (value.Bool != null) {
                serializer.Serialize (writer, value.Bool.Value);
                return;
            }
            if (value.Enum != null) {
                switch (value.Enum) {
                    case CloseOnExitEnum.Always:
                        serializer.Serialize (writer, "always");
                        return;
                    case CloseOnExitEnum.Graceful:
                        serializer.Serialize (writer, "graceful");
                        return;
                    case CloseOnExitEnum.Never:
                        serializer.Serialize (writer, "never");
                        return;
                }
            }
            throw new Exception ("Cannot marshal type CloseOnExitUnion");
        }

        public static readonly CloseOnExitUnionConverter Singleton = new CloseOnExitUnionConverter ();
    }

    internal class CloseOnExitEnumConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (CloseOnExitEnum) || t == typeof (CloseOnExitEnum?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "always":
                    return CloseOnExitEnum.Always;
                case "graceful":
                    return CloseOnExitEnum.Graceful;
                case "never":
                    return CloseOnExitEnum.Never;
            }
            throw new Exception ("Cannot unmarshal type CloseOnExitEnum");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (CloseOnExitEnum) untypedValue;
            switch (value) {
                case CloseOnExitEnum.Always:
                    serializer.Serialize (writer, "always");
                    return;
                case CloseOnExitEnum.Graceful:
                    serializer.Serialize (writer, "graceful");
                    return;
                case CloseOnExitEnum.Never:
                    serializer.Serialize (writer, "never");
                    return;
            }
            throw new Exception ("Cannot marshal type CloseOnExitEnum");
        }

        public static readonly CloseOnExitEnumConverter Singleton = new CloseOnExitEnumConverter ();
    }

    internal class CursorShapeConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (CursorShape) || t == typeof (CursorShape?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "bar":
                    return CursorShape.Bar;
                case "emptyBox":
                    return CursorShape.EmptyBox;
                case "filledBox":
                    return CursorShape.FilledBox;
                case "underscore":
                    return CursorShape.Underscore;
                case "vintage":
                    return CursorShape.Vintage;
            }
            throw new Exception ("Cannot unmarshal type CursorShape");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (CursorShape) untypedValue;
            switch (value) {
                case CursorShape.Bar:
                    serializer.Serialize (writer, "bar");
                    return;
                case CursorShape.EmptyBox:
                    serializer.Serialize (writer, "emptyBox");
                    return;
                case CursorShape.FilledBox:
                    serializer.Serialize (writer, "filledBox");
                    return;
                case CursorShape.Underscore:
                    serializer.Serialize (writer, "underscore");
                    return;
                case CursorShape.Vintage:
                    serializer.Serialize (writer, "vintage");
                    return;
            }
            throw new Exception ("Cannot marshal type CursorShape");
        }

        public static readonly CursorShapeConverter Singleton = new CursorShapeConverter ();
    }

    internal class MinMaxLengthCheckConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (string);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            var value = serializer.Deserialize<string> (reader);
            if (value.Length >= 1) {
                return value;
            }
            throw new Exception ("Cannot unmarshal type string");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (string) untypedValue;
            if (value.Length >= 1) {
                serializer.Serialize (writer, value);
                return;
            }
            throw new Exception ("Cannot marshal type string");
        }

        public static readonly MinMaxLengthCheckConverter Singleton = new MinMaxLengthCheckConverter ();
    }

    internal class ScrollbarStateConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (ScrollbarState) || t == typeof (ScrollbarState?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "hidden":
                    return ScrollbarState.Hidden;
                case "visible":
                    return ScrollbarState.Visible;
            }
            throw new Exception ("Cannot unmarshal type ScrollbarState");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (ScrollbarState) untypedValue;
            switch (value) {
                case ScrollbarState.Hidden:
                    serializer.Serialize (writer, "hidden");
                    return;
                case ScrollbarState.Visible:
                    serializer.Serialize (writer, "visible");
                    return;
            }
            throw new Exception ("Cannot marshal type ScrollbarState");
        }

        public static readonly ScrollbarStateConverter Singleton = new ScrollbarStateConverter ();
    }

    internal class RowsToScrollConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (RowsToScroll) || t == typeof (RowsToScroll?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            switch (reader.TokenType) {
                case JsonToken.Integer:
                    var integerValue = serializer.Deserialize<long> (reader);
                    return new RowsToScroll { Integer = integerValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string> (reader);
                    return new RowsToScroll { String = stringValue };
            }
            throw new Exception ("Cannot unmarshal type RowsToScroll");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            var value = (RowsToScroll) untypedValue;
            if (value.Integer != null) {
                serializer.Serialize (writer, value.Integer.Value);
                return;
            }
            if (value.String != null) {
                serializer.Serialize (writer, value.String);
                return;
            }
            throw new Exception ("Cannot marshal type RowsToScroll");
        }

        public static readonly RowsToScrollConverter Singleton = new RowsToScrollConverter ();
    }

    internal class TabWidthModeConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (TabWidthMode) || t == typeof (TabWidthMode?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "equal":
                    return TabWidthMode.Equal;
                case "titleLength":
                    return TabWidthMode.TitleLength;
            }
            throw new Exception ("Cannot unmarshal type TabWidthMode");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (TabWidthMode) untypedValue;
            switch (value) {
                case TabWidthMode.Equal:
                    serializer.Serialize (writer, "equal");
                    return;
                case TabWidthMode.TitleLength:
                    serializer.Serialize (writer, "titleLength");
                    return;
            }
            throw new Exception ("Cannot marshal type TabWidthMode");
        }

        public static readonly TabWidthModeConverter Singleton = new TabWidthModeConverter ();
    }

    internal class ThemeConverter : JsonConverter {
        public override bool CanConvert (Type t) => t == typeof (Theme) || t == typeof (Theme?);

        public override object ReadJson (JsonReader reader, Type t, object existingValue, JsonSerializer serializer) {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string> (reader);
            switch (value) {
                case "dark":
                    return Theme.Dark;
                case "light":
                    return Theme.Light;
                case "system":
                    return Theme.System;
            }
            throw new Exception ("Cannot unmarshal type Theme");
        }

        public override void WriteJson (JsonWriter writer, object untypedValue, JsonSerializer serializer) {
            if (untypedValue == null) {
                serializer.Serialize (writer, null);
                return;
            }
            var value = (Theme) untypedValue;
            switch (value) {
                case Theme.Dark:
                    serializer.Serialize (writer, "dark");
                    return;
                case Theme.Light:
                    serializer.Serialize (writer, "light");
                    return;
                case Theme.System:
                    serializer.Serialize (writer, "system");
                    return;
            }
            throw new Exception ("Cannot marshal type Theme");
        }

        public static readonly ThemeConverter Singleton = new ThemeConverter ();
    }
}
